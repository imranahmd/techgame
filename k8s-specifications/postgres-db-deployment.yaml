apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: db
  name: db
spec:
  replicas: 1
  selector:
    matchLabels:
      app: db
  template:
    metadata:
      labels:
        app: db
    spec:
      containers:
      - image: postgres:15-alpine
        name: postgres
        env:
        - name: POSTGRES_USER
          value: postgres
        - name: POSTGRES_PASSWORD
          value: postgres
        ports:
        - containerPort: 5432
          name: postgres
        volumeMounts:
        - mountPath: /var/lib/postgresql/data
          name: db-data
      volumes:
      - name: db-data
        emptyDir: {} 



        ====================================
        apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  labels:
    app: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:15-alpine
          ports:
            - containerPort: 5432
              name: postgres
          env:
            - name: POSTGRES_USER
              value: "admin"
            - name: POSTGRES_PASSWORD
              value: "Admin@123"
            - name: POSTGRES_DB
              value: "app_db"
          resources:
            requests:
              memory: "256Mi"
              cpu: "200m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
      volumes:
        - name: postgres-data
          persistentVolumeClaim:
            claimName: postgres-pvc
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi



db-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  labels:
    app: postgres

ðŸ§  Explanation:

apiVersion: apps/v1 â†’ tells Kubernetes which API to use (Deployments use apps/v1).

kind: Deployment â†’ defines the type of resource.
A Deployment ensures a specified number of identical Pods are always running.

metadata.name â†’ gives this Deployment a name (postgres).

metadata.labels â†’ labels are tags used for identification (important for Services and monitoring).

spec:
  replicas: 1


replicas: 1 â†’ means only one Pod will run.
PostgreSQL is typically a single instance (stateful), not scaled horizontally via Deployment.
(If you need high availability, youâ€™d use a StatefulSet instead.)

  selector:
    matchLabels:
      app: postgres


selector.matchLabels â†’ links this Deployment to Pods with the label app: postgres.
Kubernetes uses this to know which Pods belong to this Deployment.

  template:
    metadata:
      labels:
        app: postgres


template â†’ defines what each Pod will look like.

metadata.labels â†’ gives each Pod the label app: postgres.
This must match the selector above â€” otherwise, the Deployment wonâ€™t recognize its own Pods.

    spec:
      containers:
        - name: postgres
          image: postgres:15-alpine


containers: â†’ list of containers in each Pod (here we have one â€” PostgreSQL).

name: postgres â†’ name for the container.

image: postgres:15-alpine â†’ Docker image from Docker Hub.

Version 15 â†’ stable PostgreSQL 15.

alpine â†’ lightweight Linux base image for small size and faster start.

          ports:
            - containerPort: 5432
              name: postgres


containerPort: 5432 â†’ the port PostgreSQL listens on by default.

name: optional but helps with reference and debugging.

          env:
            - name: POSTGRES_USER
              value: "admin"
            - name: POSTGRES_PASSWORD
              value: "Admin@123"
            - name: POSTGRES_DB
              value: "app_db"


env: sets environment variables inside the container.
These are recognized by the PostgreSQL image to initialize a database on first startup:

Variable	Purpose
POSTGRES_USER	Creates a PostgreSQL superuser with this username
POSTGRES_PASSWORD	Password for that user
POSTGRES_DB	Database name automatically created when the container starts

ðŸ§  So, after the Pod starts:

A PostgreSQL instance runs on port 5432

A user admin with password Admin@123 is created

A database app_db is automatically created and owned by admin

          resources:
            requests:
              memory: "256Mi"
              cpu: "200m"
            limits:
              memory: "512Mi"
              cpu: "500m"


resources: controls CPU and memory usage.

requests: the minimum guaranteed resources for this Pod.

limits: the maximum resources the Pod can use.
This helps ensure your PostgreSQL Pod doesnâ€™t overload the cluster.

          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data


volumeMounts: connects a volume (defined below) into the containerâ€™s filesystem.

mountPath is where PostgreSQL stores its database files.

/var/lib/postgresql/data is the official data directory in the image.

âœ… So your actual database data (tables, schema, rows, etc.) will live on that volume, not inside the container.

      volumes:
        - name: postgres-data
          persistentVolumeClaim:
            claimName: postgres-pvc


This defines the volume named postgres-data.

It uses a PersistentVolumeClaim (PVC) called postgres-pvc.

ðŸ§  This means:

Kubernetes will attach real storage (disk, EBS volume, NFS, etc.) to this Pod.

Even if the Pod restarts or moves to another node, data remains intact.

Without a PVC (if you used emptyDir), you would lose all data on Pod restart.

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi

ðŸ§  Explanation:

This creates the PersistentVolumeClaim itself.

Field	Description
apiVersion: v1	Core API for persistent volumes
kind: PersistentVolumeClaim	Requests persistent storage from the cluster
metadata.name	The name (postgres-pvc) must match the Deployment volume reference
accessModes: ReadWriteOnce	Volume can be mounted by only one node at a time (perfect for databases)
resources.requests.storage: 2Gi	Requests 2 GB of storage for PostgreSQL data

ðŸ’¡ Depending on your cluster setup, this PVC will dynamically create a PersistentVolume (e.g., EBS on AWS or local disk in Minikube).

ðŸ§¾ Summary of What Happens

When you apply db-deployment.yaml:

Kubernetes creates a PersistentVolumeClaim (postgres-pvc).

It provisions 2GB of disk space.

A Deployment called postgres runs one Pod.

The Pod contains a PostgreSQL container.

PostgreSQL:

Starts with DB name app_db

Creates a user admin

Sets password Admin@123

Data is stored in /var/lib/postgresql/data â€” backed by the PVC (postgres-pvc).

Even if Pod restarts â†’ data persists.
