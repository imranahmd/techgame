apiVersion: v1
kind: Service
metadata: 
  name: frontend
  namespace: three-tier
spec:
  ports:
  - port: 3000
    protocol: TCP
  type: ClusterIP
  selector:
    role: frontend



    =======================

    apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: production
  labels:
    app: frontend
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"  # Use AWS Network Load Balancer
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
spec:
  type: LoadBalancer
  selector:
    app: frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80

      ==============================


      Detailed Explanation

Weâ€™ll break it down section by section ğŸ‘‡

ğŸ·ï¸ Metadata Section
metadata:
  name: frontend-service
  namespace: production
  labels:
    app: frontend


name: Identifies your service in the cluster (frontend-service).

namespace: Tells Kubernetes this service belongs to your production environment (same as the frontend deployment).

labels: Key-value pair for organization; helps identify and link this service with your pods.

ğŸ’¡ Kubernetes best practice: use matching namespaces for backend, frontend, and db (like production) to keep things isolated and manageable.

ğŸ§© Annotations (AWS-Specific Magic)
annotations:
  service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
  service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"


These are AWS EKS annotations that tell Kubernetes how to configure the Load Balancer in AWS.

Annotation	Description
aws-load-balancer-type: "nlb"	Creates a Network Load Balancer (NLB) instead of a Classic Load Balancer.
âœ… Ideal for production: low latency, high throughput, static IP support.
aws-load-balancer-scheme: "internet-facing"	Makes the NLB public â€” accessible from the internet.
For internal-only apps (e.g., internal dashboards), use "internal".

âš¡ AWS creates this Load Balancer automatically when you apply the YAML.
Youâ€™ll see it appear in your AWS EC2 â†’ Load Balancers dashboard.

âš™ï¸ Spec Section
spec:
  type: LoadBalancer


type: LoadBalancer â€” This is key.
It tells Kubernetes:

â€œCreate an external AWS Load Balancer and connect it to my service.â€

When this is deployed:

EKS automatically provisions an NLB in your AWS account.

Assigns a public DNS name (like a1b2c3d4e5f6.elb.amazonaws.com).

Forwards requests from that Load Balancer to your frontend pods.

ğŸ”— You can use this DNS directly or map it to a custom domain (e.g. app.mycompany.com) via Route 53.

ğŸ¯ Selector
selector:
  app: frontend


Connects the Service to the Pods created by your frontend-deployment.yaml.

The selector matches labels (app: frontend).

This means: â€œSend traffic from the Load Balancer to all pods labeled app=frontend.â€

ğŸŒ Ports Configuration
ports:
  - protocol: TCP
    port: 80
    targetPort: 80

Field	Description
protocol: TCP	HTTP traffic runs on TCP protocol.
port: 80	The external port that clients (users) will access.
targetPort: 80	The internal container port (from your deployment).
This is where Nginx in your frontend container listens.

So when a user visits:

http://<AWS-LoadBalancer-DNS>:80


â†’ Kubernetes routes that request
â†’ To your frontend pods on port 80 inside the cluster.

âš™ï¸ How It Works in AWS EKS (Step-by-Step)

You run:

kubectl apply -f frontend-service.yaml


EKS creates:

A Service object in Kubernetes.

An NLB (Network Load Balancer) in AWS automatically.

AWS assigns:

A Public DNS name (like a1b2c3d4e5f6.elb.amazonaws.com).

Connects that NLB to your worker node ENIs (Elastic Network Interfaces).

Traffic flow:

User â†’ AWS Load Balancer (port 80)
      â†’ NodePort on EKS node
      â†’ Frontend Pod (container port 80)


Kubernetes keeps everything synced automatically (if pods scale or restart).

ğŸš€ Production Enhancements (Highly Recommended)
Enhancement	Description
âœ… HTTPS/SSL	Use AWS Load Balancer Controller with ALB + ACM certificate for HTTPS.
âœ… Custom Domain	Add a DNS record in Route 53 â†’ point your domain to Load Balancer DNS.
âœ… Autoscaling	Add HorizontalPodAutoscaler (HPA) for scaling based on CPU/memory usage.
âœ… Monitoring	Use Prometheus + Grafana or CloudWatch to monitor NLB & service metrics.
âœ… Internal Access (optional)	Change "internet-facing" â†’ "internal" if you only want private VPC access.
ğŸ§© Example Output

After applying:

kubectl get svc -n production


Youâ€™ll see:

NAME                TYPE           CLUSTER-IP      EXTERNAL-IP
frontend-service    LoadBalancer   10.100.34.12    a1b2c3d4e5f6.elb.amazonaws.com


You can now open in browser:

http://a1b2c3d4e5f6.elb.amazonaws.com


ğŸ‰ Your React app is live on AWS EKS via Load Balancer!


=========================

apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  labels:
    app: frontend
spec:
  type: LoadBalancer
  selector:
    app: frontend
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 80
apiVersion: v1

This defines that youâ€™re using the core Kubernetes API version v1, which includes built-in resource types like Service, Pod, and ConfigMap.

ğŸ§± kind: Service

This tells Kubernetes that the YAML file defines a Service object â€” its job is to expose and route traffic to pods (in this case, the frontend pods created by your frontend-deployment.yaml).

ğŸªª metadata
metadata:
  name: frontend-service
  labels:
    app: frontend


name: Unique name of the Service within the namespace (frontend-service).

labels: Tags used for identifying and grouping related Kubernetes objects (here, all resources related to the frontend app).

ğŸ¯ spec.type: LoadBalancer

This is the key setting for AWS EKS production environments.

ğŸ‘‰ What it does:

Instructs Kubernetes to provision an AWS Elastic Load Balancer (ELB) automatically.

The ELB will be publicly accessible on the internet.

It forwards external traffic (port 80 on the ELB) to your frontend pods inside the EKS cluster.

ğŸ’¡ In short:
EKS â†’ AWS Load Balancer Controller â†’ Creates an ELB â†’ Routes internet traffic to your app.

ğŸ” selector
selector:
  app: frontend


This connects the Service to the pods labeled with app: frontend â€” meaning, all traffic to this Service will be sent to those pods (the frontend Deployment).

âœ… So it automatically routes traffic to the 3 replicas created in frontend-deployment.yaml.

ğŸŒ ports
ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: 80


Letâ€™s break it down:

Field	Description
name: http	Optional label for the port, useful for clarity.
protocol: TCP	Most web traffic uses TCP protocol.
port: 80	The port that the Service (and ELB) will listen on externally.
targetPort: 80	The internal container port on which your frontend (Nginx) app is running.

So traffic flow looks like this ğŸ‘‡
ğŸŒ Internet â†’ AWS ELB (port 80) â†’ Frontend Service â†’ Frontend Pods (port 80)

â˜ï¸ What Happens in AWS EKS

When you apply this YAML:

kubectl apply -f frontend-service.yaml


Kubernetes Service of type LoadBalancer is created.

The AWS Load Balancer Controller detects it and automatically creates an Elastic Load Balancer (ELB) in your AWS account.

AWS assigns:

A public DNS name, e.g.
a1b2c3d4e5f6.ap-south-1.elb.amazonaws.com

A public IP.

The ELB starts routing incoming traffic on port 80 â†’ to the EKS nodes â†’ to your React frontend pods.

âš¡ In Production
Feature	Description
Highly Available	ELB routes traffic to multiple frontend pods (replicas) â€” even across different AZs (Availability Zones).
Scalable	You can scale pods with kubectl scale and ELB will automatically detect new ones.
DNS Based	AWS provides a stable DNS name for the frontend (you can map it to your own domain via Route53).
Secure	You can later attach an SSL certificate (HTTPS) using AWS Certificate Manager (ACM) + annotations.
ğŸ’¡ Example: Add HTTPS (optional)

If you want HTTPS, you can enhance your service with annotations like:

metadata:
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: <ACM-CERT-ARN>
    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
spec:
  ports:
    - name: https
      port: 443
      targetPort: 80


That automatically provisions an HTTPS ELB using your certificate from ACM.

ğŸ” Typical Flow (Production)
User â†’ ELB DNS (frontend-service) â†’ React App (port 80)
React â†’ calls Backend API (backend-service LoadBalancer)
Backend â†’ interacts with Database (MySQL)

